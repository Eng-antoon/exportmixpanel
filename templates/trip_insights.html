{% extends "layout.html" %}
{% block content %}
<!-- Navigation Bar (Retained for Trip Insights) -->

<!-- Main Heading -->
<h1 class="mt-4">Trip Insights</h1>

<div class="row animate__animated animate__fadeInUp">
  <div class="col-md-6">
    <h3>Route Quality Counts</h3>
    <ul class="list-group">
      <li class="list-group-item">No Logs Trips: {{ quality_counts["No Logs Trips"] }}</li>
      <li class="list-group-item">Trip Points Only Exist: {{ quality_counts["Trip Points Only Exist"] }}</li>
      <li class="list-group-item">Low: {{ quality_counts["Low"] }}</li>
      <li class="list-group-item">Moderate: {{ quality_counts["Moderate"] }}</li>
      <li class="list-group-item">High: {{ quality_counts["High"] }}</li>
      <li class="list-group-item">No Quality Set: {{ quality_counts[""] }}</li>
    </ul>
  </div>
  <div class="col-md-6">
    <h3>Distance Averages</h3>
    <ul class="list-group">
      <li class="list-group-item">Average Manual Distance: {{ avg_manual|round(2) }}</li>
      <li class="list-group-item">Average Calculated Distance: {{ avg_calculated|round(2) }}</li>
    </ul>
  </div>
</div>

<div class="row mt-4 animate__animated animate__fadeInUp">
  <div class="col-md-6">
    <h3>Distance Consistency</h3>
    <ul class="list-group">
      <li class="list-group-item">Consistent Trips: {{ consistent }}</li>
      <li class="list-group-item">Inconsistent Trips: {{ inconsistent }}</li>
    </ul>
  </div>
</div>

<!-- New Dashboard Sections Start -->
<hr class="mt-4">
<h2 class="mt-5">Additional Dynamic Dashboards</h2>

<div class="card mb-4 animate__animated animate__fadeInUp">
  <div class="card-header">
    Trip Quality Distribution & Segmentation
  </div>
  <div class="card-body">
    <p>This dashboard shows the distribution of trip quality scores (No Logs Trips, Trip Points Only Exist, Low, Moderate, High, No Quality Set). It updates automatically based on the Excel and database data. Use this to understand the overall segmentation of trips.</p>
    <canvas id="qualityDistributionChart"></canvas>
  </div>
</div>

<div class="card mb-4 animate__animated animate__fadeInUp">
  <div class="card-header">
    Quality Category Drill-Down
  </div>
  <div class="card-body">
    <p>Select a quality category from the dropdown to view the breakdown of device specifications (based on model) associated with that quality segment. This chart helps identify common device models among high, moderate, or low quality trips.</p>
    <select id="qualitySelect" class="form-select mb-3" style="max-width:200px;">
      <option value="High">High</option>
      <option value="Moderate">Moderate</option>
      <option value="Low">Low</option>
    </select>
    <canvas id="qualityDrilldownChart"></canvas>
  </div>
</div>

<div class="card mb-4 animate__animated animate__fadeInUp">
  <div class="card-header">
    Hardware Specification Impact
  </div>
  <div class="card-body">
    <p>This bar chart shows the distribution of trip quality across different RAM capacities. It dynamically updates based on the trip quality types.</p>
    <canvas id="ramChart"></canvas>
  </div>
</div>

<div class="card mb-4 animate__animated animate__fadeInUp">
  <div class="card-header">
    Sensor & Feature Availability
  </div>
  <div class="card-body">
    <p>This grouped bar chart displays the percentage availability of various sensors (Fingerprint Sensor, Accelerometer, Gyro, Proximity Sensor, Compass, Barometer, Background Task Killing Tendency) for each trip quality category. It helps identify if missing sensors might be contributing to lower quality trips.</p>
    <canvas id="sensorChart"></canvas>
  </div>
</div>

<div class="card mb-4 animate__animated animate__fadeInUp">
  <div class="card-header">
    OS & Software Impact on Trip Quality
  </div>
  <div class="card-body">
    <p>This stacked bar chart shows how trip quality is distributed across different Android versions. It provides insights on whether certain OS versions are associated with differing trip quality levels.</p>
    <canvas id="osQualityChart"></canvas>
  </div>
</div>

<div class="card mb-4 animate__animated animate__fadeInUp">
  <div class="card-header">
    Manufacturer & Model Analysis
  </div>
  <div class="card-body">
    <p>This dashboard presents the distribution of trip quality across different manufacturers. Analyze which manufacturers have higher quality trips and whether specific models consistently yield better performances.</p>
    <canvas id="manufacturerChart"></canvas>
  </div>
</div>

<div class="card mb-4 animate__animated animate__fadeInUp">
  <div class="card-header">
    Carrier & Device Interaction
  </div>
  <div class="card-body">
    <p>This dashboard shows the distribution of trip quality segmented by carrier. It helps pinpoint if certain carriers have a higher proportion of high or low quality trips, which may indicate network-related influences.</p>
    <canvas id="carrierChart"></canvas>
  </div>
</div>

<div class="card mb-4 animate__animated animate__fadeInUp">
  <div class="card-header">
    Temporal Trends in Trip Quality
  </div>
  <div class="card-body">
    <p>This line chart visualizes trip quality over time based on the timestamps from the Excel data. Use it to identify seasonal trends or the impact of device aging on trip quality.</p>
    <canvas id="timeSeriesChart"></canvas>
  </div>
</div>

<div class="card mb-4 animate__animated animate__fadeInUp">
  <div class="card-header">
    Advanced Analytics & Predictive Insights
  </div>
  <div class="card-body">
    <p>Currently, the predictive analytics dashboard is not implemented due to missing data points such as battery capacity and storage details. Once these data are available, advanced predictive modeling and anomaly detection will be implemented to forecast trip quality and identify outliers.</p>
  </div>
</div>

<!-- New Dashboards -->

<div class="card mb-4 animate__animated animate__fadeInUp">
  <div class="card-header">
    Average Trip Duration vs Trip Quality
  </div>
  <div class="card-body">
    <p>This dashboard shows the average trip duration (in hours) for each trip quality category.</p>
    <canvas id="avgTripDurationChart"></canvas>
  </div>
</div>

<div class="card mb-4 animate__animated animate__fadeInUp">
  <div class="card-header">
    Completed By vs Trip Quality
  </div>
  <div class="card-body">
    <p>This grouped bar chart displays, for each quality category, how many trips were completed by each type (e.g. driver vs admin).</p>
    <canvas id="completedByChart"></canvas>
  </div>
</div>

<div class="card mb-4 animate__animated animate__fadeInUp">
  <div class="card-header">
    Average Logs Count vs Trip Quality
  </div>
  <div class="card-body">
    <p>This bar chart shows the average log count (using coordinate_count) per trip quality category.</p>
    <canvas id="avgLogsCountChart"></canvas>
  </div>
</div>
<!-- New Dashboard Sections End -->

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
/* Chart initialization code for Trip Insights Dashboard */
const qualityDistributionData = JSON.parse('{{ quality_counts|tojson }}');
const qualityDrilldownData = JSON.parse('{{ quality_drilldown|tojson }}');
const sensorStats = JSON.parse('{{ sensor_stats|tojson }}');
const qualityByOs = JSON.parse('{{ quality_by_os|tojson }}');
const manufacturerQuality = JSON.parse('{{ manufacturer_quality|tojson }}');
const carrierQuality = JSON.parse('{{ carrier_quality|tojson }}');
const timeSeries = JSON.parse('{{ time_series|tojson }}');
const ramQualityCounts = JSON.parse('{{ ram_quality_counts|tojson }}');

Chart.defaults.font.size = 14;

// Trip Quality Distribution - Bar Chart
const ctxQualityDistribution = document.getElementById('qualityDistributionChart').getContext('2d');
window.qualityDistributionChart = new Chart(ctxQualityDistribution, {
  type: 'bar',
  data: {
    labels: Object.keys(qualityDistributionData),
    datasets: [{
      label: 'Trip Count',
      data: Object.values(qualityDistributionData),
      backgroundColor: 'rgba(54, 162, 235, 0.7)'
    }]
  },
  options: {
    plugins: {
      title: {
        display: true,
        text: 'Trip Quality Distribution'
      }
    },
    scales: {
      x: { stacked: false, ticks: { autoSkip: false } },
      y: { beginAtZero: true }
    }
  }
});

// Quality Drill-Down: Interactive Chart
function renderDrilldownChart(quality) {
  const data = qualityDrilldownData[quality];
  if (!data) return;
  const labels = Object.keys(data.model);
  const modelData = Object.values(data.model);
  const ctxDrilldown = document.getElementById('qualityDrilldownChart').getContext('2d');
  if(window.qualityDrilldownChart && typeof window.qualityDrilldownChart.destroy === 'function') {
      window.qualityDrilldownChart.destroy();
  }
  window.qualityDrilldownChart = new Chart(ctxDrilldown, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [{
        label: 'Model Count',
        data: modelData,
        backgroundColor: 'rgba(255, 99, 132, 0.7)'
      }]
    },
    options: {
      plugins: {
        title: {
          display: true,
          text: 'Device Specs Drill-Down for ' + quality + ' Quality Trips'
        }
      },
      scales: {
        x: { stacked: false, ticks: { autoSkip: false } },
        y: { beginAtZero: true }
      }
    }
  });
}

document.getElementById('qualitySelect').addEventListener('change', function() {
  renderDrilldownChart(this.value);
});
// Initialize drilldown with default selected value
renderDrilldownChart(document.getElementById('qualitySelect').value);

// RAM Distribution Chart
let ramLabels = Object.keys(ramQualityCounts);
ramLabels.sort((a, b) => parseInt(a) - parseInt(b));
let qualityLevelsSet = new Set();
ramLabels.forEach(ram => {
  Object.keys(ramQualityCounts[ram]).forEach(q => qualityLevelsSet.add(q));
});
let qualityLevels = Array.from(qualityLevelsSet);
qualityLevels.sort((a, b) => {
  const order = {"High": 1, "Moderate": 2, "Low": 3, "No Logs Trips": 4, "Trip Points Only Exist": 5, "Empty": 6};
  return (order[a] || 7) - (order[b] || 7);
});
let datasets = qualityLevels.map(q => {
  return {
    label: q,
    data: ramLabels.map(ram => ramQualityCounts[ram][q] || 0),
    backgroundColor: q === "Low" ? "rgba(255, 99, 132, 0.7)" : q === "Moderate" ? "rgba(54, 162, 235, 0.7)" : q === "High" ? "rgba(75, 192, 192, 0.7)" : "rgba(153, 102, 255, 0.7)"
  };
});
const ctxRam = document.getElementById('ramChart').getContext('2d');
window.ramChart = new Chart(ctxRam, {
  type: 'bar',
  data: {
    labels: ramLabels,
    datasets: datasets
  },
  options: {
    plugins: {
      title: {
        display: true,
        text: 'Trip Quality Distribution by RAM'
      }
    },
    responsive: true,
    scales: {
      x: { title: { display: true, text: 'RAM Capacity' } },
      y: { beginAtZero: true, title: { display: true, text: 'Number of Trips' } }
    }
  }
});

// Sensor & Feature Availability Chart
const sensorLabels = Object.keys(sensorStats["Fingerprint Sensor"] || {});
let sensorDatasets = [];
Object.keys(sensorStats).forEach(sensor => {
  const data = sensorLabels.map(q => {
    if(sensorStats[sensor][q]) {
      return Math.round((sensorStats[sensor][q].present / sensorStats[sensor][q].total) * 100);
    }
    return 0;
  });
  sensorDatasets.push({
    label: sensor,
    data: data,
    backgroundColor: 'rgba(153, 102, 255, 0.7)'
  });
});
const ctxSensor = document.getElementById('sensorChart').getContext('2d');
window.sensorChart = new Chart(ctxSensor, {
  type: 'bar',
  data: {
    labels: sensorLabels,
    datasets: sensorDatasets
  },
  options: {
    plugins: {
      title: { display: true, text: 'Sensor Availability by Trip Quality (%)' }
    },
    scales: {
      x: { stacked: false, ticks: { autoSkip: false } },
      y: { beginAtZero: true, max: 100 }
    }
  }
});

// OS & Software Impact Chart
const osLabels = Object.keys(qualityByOs);
const osDatasets = [];
const qualityCategories = new Set();
Object.values(qualityByOs).forEach(obj => { Object.keys(obj).forEach(q => qualityCategories.add(q)); });
qualityCategories.forEach(q => {
  const data = osLabels.map(os => qualityByOs[os][q] || 0);
  osDatasets.push({
    label: q,
    data: data,
    backgroundColor: 'rgba(255, 206, 86, 0.7)'
  });
});
const ctxOsQuality = document.getElementById('osQualityChart').getContext('2d');
window.osQualityChart = new Chart(ctxOsQuality, {
  type: 'bar',
  data: { labels: osLabels, datasets: osDatasets },
  options: {
    plugins: { title: { display: true, text: 'Trip Quality by Android Version' } },
    responsive: true,
    scales: { x: { stacked: false, ticks: { autoSkip: false } }, y: { stacked: false, beginAtZero: true } }
  }
});

// Manufacturer & Model Analysis Chart
const manuLabels = Object.keys(manufacturerQuality);
const manuDatasets = [];
const manuQualityCategories = new Set();
Object.values(manufacturerQuality).forEach(obj => { Object.keys(obj).forEach(q => manuQualityCategories.add(q)); });
manuQualityCategories.forEach(q => {
  const data = manuLabels.map(manu => manufacturerQuality[manu][q] || 0);
  manuDatasets.push({
    label: q,
    data: data,
    backgroundColor: 'rgba(54, 162, 235, 0.7)'
  });
});
const ctxManufacturer = document.getElementById('manufacturerChart').getContext('2d');
window.manufacturerChart = new Chart(ctxManufacturer, {
  type: 'bar',
  data: { labels: manuLabels, datasets: manuDatasets },
  options: {
    plugins: { title: { display: true, text: 'Trip Quality by Manufacturer' } },
    responsive: true,
    scales: { x: { stacked: false, ticks: { autoSkip: false } }, y: { stacked: false, beginAtZero: true } }
  }
});

// Carrier & Device Interaction Chart
const carrierLabels = Object.keys(carrierQuality);
const carrierDatasets = [];
const carrierQualityCategories = new Set();
Object.values(carrierQuality).forEach(obj => { Object.keys(obj).forEach(q => carrierQualityCategories.add(q)); });
carrierQualityCategories.forEach(q => {
  const data = carrierLabels.map(carrier => carrierQuality[carrier][q] || 0);
  carrierDatasets.push({
    label: q,
    data: data,
    backgroundColor: 'rgba(255, 99, 132, 0.7)'
  });
});
const ctxCarrier = document.getElementById('carrierChart').getContext('2d');
window.carrierChart = new Chart(ctxCarrier, {
  type: 'bar',
  data: { labels: carrierLabels, datasets: carrierDatasets },
  options: {
    indexAxis: 'x',
    responsive: true,
    scales: { x: { stacked: false, ticks: { autoSkip: false } }, y: { stacked: false, beginAtZero: true } }
  }
});

// Temporal Trends Chart
const timeLabels = Object.keys(timeSeries);
const timeDatasets = [];
const timeQualityCategories = new Set();
Object.values(timeSeries).forEach(obj => { Object.keys(obj).forEach(q => timeQualityCategories.add(q)); });
timeQualityCategories.forEach(q => {
  const datasetData = timeLabels.map(date => timeSeries[date][q] || 0);
  timeDatasets.push({
    label: q,
    data: datasetData,
    backgroundColor: 'rgba(75, 192, 192, 0.7)',
    borderColor: 'rgba(75, 192, 192, 1)',
    fill: false
  });
});
const ctxTimeSeries = document.getElementById('timeSeriesChart').getContext('2d');
window.timeSeriesChart = new Chart(ctxTimeSeries, {
  type: 'line',
  data: { labels: timeLabels, datasets: timeDatasets },
  options: {
    plugins: { title: { display: true, text: 'Temporal Trends in Trip Quality' } },
    responsive: true,
    scales: { y: { beginAtZero: true } }
  }
});

///////////////////////////////////////////////
// New Chart: Average Trip Duration vs Trip Quality
const avgTripDurationData = JSON.parse('{{ avg_trip_duration_quality|tojson }}');
const durationLabels = Object.keys(avgTripDurationData);
const durationValues = Object.values(avgTripDurationData);
const ctxAvgTripDuration = document.getElementById('avgTripDurationChart').getContext('2d');
new Chart(ctxAvgTripDuration, {
    type: 'bar',
    data: {
        labels: durationLabels,
        datasets: [{
            label: 'Average Trip Duration (h)',
            data: durationValues,
            backgroundColor: 'rgba(54, 162, 235, 0.7)'
        }]
    },
    options: {
        scales: {
            y: { beginAtZero: true }
        }
    }
});

///////////////////////////////////////////////
// New Chart: Completed By vs Trip Quality
const completedByData = JSON.parse('{{ completed_by_quality|tojson }}');
const qualityCategoriesForCompleted = Object.keys(completedByData);
let completionTypes = new Set();
qualityCategoriesForCompleted.forEach(q => {
    Object.keys(completedByData[q]).forEach(type => completionTypes.add(type));
});
completionTypes = Array.from(completionTypes);
const colors = [
  'rgba(255, 99, 132, 0.7)',
  'rgba(75, 192, 192, 0.7)',
  'rgba(255, 206, 86, 0.7)',
  'rgba(153, 102, 255, 0.7)',
  'rgba(255, 159, 64, 0.7)'
];
const completedByChartDatasets = completionTypes.map((type, index) => {
    const data = qualityCategoriesForCompleted.map(q => completedByData[q][type] || 0);
    return {
        label: type,
        data: data,
        backgroundColor: colors[index % colors.length]
    };
});
const ctxCompletedBy = document.getElementById('completedByChart').getContext('2d');
new Chart(ctxCompletedBy, {
    type: 'bar',
    data: {
        labels: qualityCategoriesForCompleted,
        datasets: completedByChartDatasets
    },
    options: {
        scales: {
            x: { stacked: false },
            y: { beginAtZero: true }
        }
    }
});

///////////////////////////////////////////////
// New Chart: Average Logs Count vs Trip Quality
const avgLogsCountData = JSON.parse('{{ avg_logs_count_quality|tojson }}');
const logsLabels = Object.keys(avgLogsCountData);
const logsValues = Object.values(avgLogsCountData);
const ctxAvgLogs = document.getElementById('avgLogsCountChart').getContext('2d');
new Chart(ctxAvgLogs, {
    type: 'bar',
    data: {
        labels: logsLabels,
        datasets: [{
            label: 'Average Logs Count',
            data: logsValues,
            backgroundColor: 'rgba(153, 102, 255, 0.7)'
        }]
    },
    options: {
        scales: {
            y: { beginAtZero: true }
        }
    }
});

// Auto-update the page every 60 seconds to refresh chart data
setInterval(function(){
  location.reload();
}, 60000);

/* Updated updateDashboards function to disable auto-update on 404 errors */
function updateDashboards() {
  fetch('/api/trip_insights_data')
    .then(response => {
      if (!response.ok) {
        throw new Error('HTTP error ' + response.status);
      }
      return response.json();
    })
    .then(data => {
      // Update Trip Quality Distribution Chart
      if(window.qualityDistributionChart) {
        window.qualityDistributionChart.data.labels = Object.keys(data.quality_counts);
        window.qualityDistributionChart.data.datasets[0].data = Object.values(data.quality_counts);
        window.qualityDistributionChart.update();
      }
      // Update Drilldown Chart based on currently selected quality
      const drillQuality = document.getElementById('qualitySelect').value;
      renderDrilldownChart(drillQuality);
      // Update Sensor Chart
      if(window.sensorChart) {
        const sensorLabels = Object.keys(data.sensor_stats["Fingerprint Sensor"] || {});
        window.sensorChart.data.labels = sensorLabels;
        let sensorDatasets = [];
        Object.keys(data.sensor_stats).forEach(sensor => {
          const sensorPercentages = sensorLabels.map(q => {
            if(data.sensor_stats[sensor][q]) {
              return Math.round((data.sensor_stats[sensor][q].present / data.sensor_stats[sensor][q].total) * 100);
            }
            return 0;
          });
          sensorDatasets.push({
             label: sensor,
             data: sensorPercentages,
             backgroundColor: 'rgba(153, 102, 255, 0.7)'
          });
        });
        window.sensorChart.data.datasets = sensorDatasets;
        window.sensorChart.update();
      }
      // Update OS Quality Chart
      if(window.osQualityChart) {
        const osLabels = Object.keys(data.quality_by_os);
        window.osQualityChart.data.labels = osLabels;
        let osDatasets = [];
        let qualityCategories = new Set();
        Object.values(data.quality_by_os).forEach(obj => { Object.keys(obj).forEach(q => qualityCategories.add(q)); });
        qualityCategories.forEach(q => {
          const datasetData = osLabels.map(os => data.quality_by_os[os][q] || 0);
          osDatasets.push({
            label: q,
            data: datasetData,
            backgroundColor: 'rgba(255, 206, 86, 0.7)'
          });
        });
        window.osQualityChart.data.datasets = osDatasets;
        window.osQualityChart.update();
      }
      // Update Manufacturer Chart
      if(window.manufacturerChart) {
        const manuLabels = Object.keys(data.manufacturer_quality);
        window.manufacturerChart.data.labels = manuLabels;
        let manuDatasets = [];
        let manuQualityCategories = new Set();
        Object.values(data.manufacturer_quality).forEach(obj => { Object.keys(obj).forEach(q => manuQualityCategories.add(q)); });
        manuQualityCategories.forEach(q => {
          const datasetData = manuLabels.map(manu => data.manufacturer_quality[manu][q] || 0);
          manuDatasets.push({
            label: q,
            data: datasetData,
            backgroundColor: 'rgba(54, 162, 235, 0.7)'
          });
        });
        window.manufacturerChart.data.datasets = manuDatasets;
        window.manufacturerChart.update();
      }
      // Update Carrier Chart
      if(window.carrierChart) {
        const carrierLabels = Object.keys(data.carrier_quality);
        window.carrierChart.data.labels = carrierLabels;
        let carrierDatasets = [];
        let carrierQualityCategories = new Set();
        Object.values(data.carrier_quality).forEach(obj => { Object.keys(obj).forEach(q => carrierQualityCategories.add(q)); });
        carrierQualityCategories.forEach(q => {
          const datasetData = carrierLabels.map(carrier => data.carrier_quality[carrier][q] || 0);
          carrierDatasets.push({
            label: q,
            data: datasetData,
            backgroundColor: 'rgba(255, 99, 132, 0.7)'
          });
        });
        window.carrierChart.data.datasets = carrierDatasets;
        window.carrierChart.update();
      }
      // Update Time Series Chart
      if(window.timeSeriesChart) {
        const timeLabels = Object.keys(data.time_series);
        window.timeSeriesChart.data.labels = timeLabels;
        let timeDatasets = [];
        let timeQualityCategories = new Set();
        Object.values(data.time_series).forEach(obj => { Object.keys(obj).forEach(q => timeQualityCategories.add(q)); });
        timeQualityCategories.forEach(q => {
          const datasetData = timeLabels.map(date => data.time_series[date][q] || 0);
          timeDatasets.push({
            label: q,
            data: datasetData,
            backgroundColor: 'rgba(75, 192, 192, 0.7)',
            borderColor: 'rgba(75, 192, 192, 1)',
            fill: false
          });
        });
        window.timeSeriesChart.data.datasets = timeDatasets;
        window.timeSeriesChart.update();
      }
    })
    .catch(err => {
      console.error('Error fetching dashboard data:', err);
      if (err.message && err.message.indexOf('404') >= 0) {
        console.error('Disabling auto-update as API endpoint not found.');
        clearInterval(dashboardInterval);
      }
    });
}

// Store the interval ID in dashboardInterval so it can be cleared if needed
var dashboardInterval = setInterval(updateDashboards, 30000);
</script>
<!-- New Dashboard Sections End -->
{% endblock %}
